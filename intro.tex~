 \begin{comment}
\section{Motivation}

% What do you mean by Internet can move? It sounds weird.
Today's Internet can move at any point. The soaring demands of client mobility over the last two decades, the growing elasticity of virtualized server, and the recent trends of elastic network function virtualiztion, impose new challenges for network infrastructure design. 

%Change the changeable, accept the unchangeable, and remove yourself from the unacceptable.--Denis Waitley

Many mobility solutions rely on an artificial choke-point, such as name server or home agent, which are installed as middleboxes in many places. Recent trends of network function virtualization aim to offer a more scalable and flexible middlebox functions, and network function migration can happen at any time. We raise a question, can we have a unified solution that can support every point (e.g., endhosts, network functions, server VMs) moving in the network? 

Although previous approaches consider some of the problem we address, none addresses all this issues in a unifying solution.

\end{comment}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\textit{Endpoints move}: The growing cellular network and WiFi hotspot coverage, Internet of things such as connected cars over the past few years have pushed the term ``mobile'' to a new era. Mobility support has become a key consideration in terms of network infrastructure design. More and more network services are run in virtualized environments; the service VMs` can run anywhere and the VM migration can happen at any moment due to load balancing, infrastructure maintenance etc... \amy{As you probably know, this paragraph is improperly placed. But we can move it around later.}


\textit{Middleboxes are ubiquitous and elastic}: Network administrators use middleboxes to apply services on the traffic exchanged between pairs of communicating endpoints. Today, they are routinely used to improve security (firewall, packet scrubber), protect user privacy (encryption, anonymization), share a set of IP addresses (network address translator), spread traffic over multiple backend servers (load balancing), reduce bandwidth consumption (compression, video transcoding, caching), monitor traffic and perform application-specific tasks. Recent trends of network function virtualization implement middleboxes as virtual machines (VMs) or user-space applications separate from the physical host. Virtualization enables running middleboxes at many different locations in the network, and the middlebox instance can spin up, down, or even migrate as load demands. 
 
To support a new Internet era where client mobility, and server and middlebox migration can take place anywhere anytime, we propose a SM3 (Server, Middlebox Migration and Mobility) architecture, that runs below an unmodified transport layer and requires no router or switch support. The core of the architecture is a new geomorphic view of today's network. The existence of middleboxes already breaks the end-to-end principle, so we capitalize on this violation to create a new abstraction for a connection. We identify each connection by a super-session and a list of sub-sessions, where a super-session represents the original end-to-end communication. Middlebox traffic steering simply stitches the sub-sessions together, and mobility and migration have the same building block operation: replacing an old sub-session with a new one. Hence, the sub-session abstraction exists to isolate middlebox operations in a super-session to individual sub-sessions. In this paper we will show how to establish a super-session and corresponding sub-sessions, and how to handle a sub-session replacement \amy{This concluding sentence is a bit awkward-- I don't know the convention for this.}.

Although previous works consider some of the problems we address, none provides a comprehensive solution for endpoint mobility, server migration and middlebox service chain and migrations. TCP Migrate~\cite{TCPMobile}, Mobile IP~\cite{mip}, Serval~\cite{serval} and ROAM~\cite{I3Mobile} support endpoint mobility, but none of them explicitly deal with the existence of Middleboxes, and some of them also suffer from deployability. DoA~\cite{DOA} proposes a name service for middlebox service chain, however it neither support flow migration cross middleboxes nor server migration. SIMPLE~\cite{SIMPLE} and OpenNF~\cite{OpenNF} take advantage of modern switches that offer fine-grained control over routing (e.g., OpenFlow enabled router), to steer traffic selectively through one or more middleboxes. However, the routing solutions fail to support endpoint mobility \amy{It is unclear thus far how you are supporting client mobility. You simply mention it in the previous paragraph. ech, maybe this discomfort will go away when you put more in the intro. Basically the previous paragraphs are awkward because you go in depth into what your architecture is, but only on the middlebox protocol part. If you're going to describe things, might as well describe the whole architecture and explain how you are achieving all your goals} and suffer from scalability and flexibility of fine-grained policy control due to the limited size of ternary content-addressable memory (TCAM). More fundamentally, we argue middleboxes should be addressed explicitly instead of treated as second-class citizen. 

In SM3 system middleboxes are addressed explicitly as the endpoints of sub-sessions and thus can be an organic part of the mobility ecosystem. SM3 achieves:
\begin{itemize}
 \item \textbf{Unified solution:} It supports client mobility, server migration, middlebox service chain and flow migration during middlebox migration.
 \item \textbf{Incrementally deployable:} The system can be deployed between client and server, client and middleboxes, or even just between middleboxes. 
 \item \textbf{Same socket abstraction:} It does not change transport layer, and thus does not require any change to the higher-level application if the application is using socket abstraction.
 \item \textbf{No routing change:} Since we address the sub-sessions explicitly by the network layer, simple solutions like shortest path routing still work.
 \item \textbf{High performance:} An in-kernel prototype shows that a shim translate layer can sustain up to 14.2 Gbps per CPU core. \amy{This shim translate layer just kind of popped up out of the blue. Do you think it is necessary to mention it briefly prior to this?}

\end{itemize}



%Most mobility proposals decouple IP and ID binding, by introducing an indirection point (e.g., Mobile IP~\cite{mip}), redirecting through DNS (e.g., TCP Migrate~\cite{TCPMobile}), or resolving persistent ID via a distributed hash table (DHT) (e.g.,ROAM~\cite{I3Mobile}). However, the solutions either lack the support for Middleboxes (e.g., ROAM) or requires an implicit fixed middlebox (e.g., home agent in Mobile IP). 




% However, getting middleboxes on (and off) a network path is unnecessarily complicated. Traditionally, middleboxes are dedicated appliances deployed at major juncture points, such as the gateway that connects an enterprise to the Internet. But this approach makes it difficult to apply middleboxes to internal traffic (staying within an enterprise or data center) or to use middleboxes selectively (e.g., allowing non-video traffic to bypass the transcoder).

% Two recent trends are making middlebox placement much more flexible. First, middleboxes are increasingly virtualized---implemented as virtual machines (VMs) that are separable from the physical host. This means that middleboxes can run at many different, strategic locations in the network, and the middlebox instances can spin up (or down) or even migrate as load demands. Second, modern switches offer fine-grained control over routing (e.g., using technologies like OpenFlow) to steer traffic selectively through one or more middleboxes. For example, web requests may traverse a firewall followed by a load balancer, while video traffic may traverse a firewall followed by transcoder. Together, these two trends turn the network into a fungible pool of resource for running services and steering traffic. 
\begin{comment}
\subsection{Middlebox-Aware Session Protocol}
We see a growing number of research papers and industry activity on controllers that perform flexible ``traffic steering" (or ``service chaining") to optimize performance and/or enforce policy. Almost exclusively, these controllers use \textit{routing} as their mechanism of control. In the worst case, the controller installs customized ``microflow" rules on demand to direct all the packets of each TCP session through the chosen sequence of middleboxes. Alternatively, the controller could proactively install coarse-grained rules that handle related TCP sessions in the same way, at the expense of less control and greater complexity. However, we argue that it is clumsy and inefficient to use routing to steer different sets of sessions through different chains of middleboxes; as it suffers from (i)\textit{scalability} and (ii)\textit{mobility}. 

We argue that middlebox-aware session protocols (MBPs) are a better way to insert and remove middleboxes on a path than routing is. Briefly, session protocols do not have scalability or flexibility problems because the information required to implement each session correctly is associated with the session itself. For the same reason, it is easy to ensure session affinity and dynamically add, remove or swap middleboxes. We store the middlebox policy at a logically centralized policy server, which functions like a DNS server or SDN controller. To achieve this, we have to address the following challenges:
%A simple comparison between MBPs and other existing systems is in Table~\ref{compare}. 

\begin{itemize}

\item \textbf{Scalable policy routing:} Due to a limited size of flow table, it is hard to put in tens of thousands to millions of ``microflow" rules in to router or switches' hardware routing table. How to decompose the middlebox policies and offload fine-grain policies to end hosts and middleboxes in an efficient way is still an open problem.

\item \textbf{Session affinity during flow migration:} Flows should be flexibly routed between different middleboxes, however, this requires either maintaining a per-session state in the switch, or having complex ``time out" rules to keep states in the controller. It is important to have a MBP which guarantees flow affinity, however asynchronosity and race condition make this problem more challenging. 

\item \textbf{Endpoint mobility and multihoming:} Today's end hosts change locations frequently due to device mobility and VM migration. In addition, newer protocols allow end devices to use multiple interfaces. We also need to address how to seamlessly integrate end hosts mobility protocols and this MBP. 

\end{itemize}
\end{comment}



The paper is organized as the following: blah...
